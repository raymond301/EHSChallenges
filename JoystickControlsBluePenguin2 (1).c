#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     IRSeeker2,      sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S4,     LightSensor,    sensorLightActive)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     Manipulator,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    release,              tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// FUNCTIONS
// Global constants
// Lowest color value for light sensor
int LSlow = 40;
// Highest color value for light sensor
int LShigh = 60;
	// Set the color of the light sensor value as black (negro is nothing more than a variable - could be 'black')
int distance_in_cm = 28;

#include "JoystickDriver.c"

bool RUNNING=true;
bool releasePushed=false;

// ********************************************************* //
// ********************************************************* //
// Main task of the program
task main()
{
	getJoystickSettings(joystick);
	servo[release]=255;
	servoChangeRate[release]=4;
  while(RUNNING)
  {
  	getJoystickSettings(joystick);
    motor[mtr_S1_C1_1] = joystick.joy1_y1;
    motor[mtr_S1_C1_2] = joystick.joy1_y2;
    // option 0 - works - i dont think it should
    //  if (joystick.joy1_y1 = 0)(joystick.joy1_y2 = 0);
    // option 1 - reset joystick position
    //joystick.joy1_y1 = 0;
    //joystick.joy1_y2 = 0;
    // option 2 - check y1 and if 0, set y2 to 0 -what compiler wants for no errors.
    //if (joystick.joy1_y1 == 0)
  	//{
  	//	joystick.joy1_y2 = 0;
  	//}

    if(joy2Btn(9))
		{
			servo[release]=360;
		}
		else if(joy2Btn(10))
		{
			servo[release] = 0;
		}
		if(joy1Btn(1))
		{
			motor[mtr_S1_C3_1] = 100;
		}
		else if(joy1Btn(2))
		{
			motor[mtr_S1_C3_1] = -40;
		}
		else
		{
			motor[mtr_S1_C3_1] = 0;
		}



		if(joy2Btn(1))
		{
			// while the light sensor is not on the black line
			while((SensorValue(LightSensor) < LSlow) && (SensorValue(LightSensor) > LShigh))
			{
				motor[mtr_S1_C1_1] = 10;
				motor[mtr_S1_C1_2] = -10;
				wait1Msec(1000);

				motor[mtr_S1_C1_1] = -10;
				motor[mtr_S1_C1_2] = 10;
				wait1Msec(2000);

				motor[mtr_S1_C1_1] = 10;
				motor[mtr_S1_C1_2] = -10;
				wait1Msec(1000);
			}

			// While robot is farther than 26cm away from the pole
    	while(SensorValue[sonarSensor] >= distance_in_cm)
    	{
     	 	// run the motors 40%
       	motor[mtr_S1_C1_1] = 40;
       	motor[mtr_S1_C1_2] = 40;

			while(SensorValue(LightSensor) < LShigh)
			{
     		// we are off target to the left, correct to right
				motor[mtr_S1_C1_1] = 20;
				motor[mtr_S1_C1_2] = 0;
			}

			while(SensorValue(LightSensor) > LShigh)
			{
				// we are off target to the right, correct to left
				motor[mtr_S1_C1_1] = 0;
				motor[mtr_S1_C1_2] = 20;
			}

			// end bracket for while sonar > distance to pole
			}

			// While the robot is less than 28cm away
			// while(SensorValue[sonarSensor] < distance_in_cm)
			// {
				motor[mtr_S1_C1_1] = 0;
				motor[mtr_S1_C1_2] = 0;
				// Stop for one second
				wait1Msec(1000);

				// Raise the manipulator for 3 seconds
				motor[mtr_S1_C3_1] = 100;
				wait1Msec(3000);

				// Move forward at 20% power for 1/2 second
				motor[mtr_S1_C1_1] = 20;
				motor[mtr_S1_C1_2] = 20;
				wait1Msec(500);

				// Lower the manipulator for 1 second
				motor[mtr_S1_C3_1] = -40;
				wait1Msec(1000);

				// Move backward at 20% power for 1/2 second
				motor[mtr_S1_C1_1] = -20;
				motor[mtr_S1_C1_2] = -20;
				wait1Msec(500);
				// }
		}
//		else
//		{
//			motor[mtr_S1_C1_1] = 0;
//			motor[mtr_S1_C1_2] = 0;
//		}
	}
}
